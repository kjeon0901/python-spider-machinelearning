'''

a = Cookie() 	//a는 객체, a는 클래스 Cookie()의 인스턴스 (걍 유연하게 생각해)
		//a는 클래스 Cookie() 안에 정의된 모든 메서드를 사용할 수 있게 됨
a.add()와 'python'.replace('p', 'a')에서의 . 사용은 일맥상통하다. 클래스 str 안에 replace라는 메서드가 정의되어 있는 것
파이썬의 각각의 변수들은 사실 클래스 객체임	type('hi'):<class 'str'>, type(1):<class 'int'>, type(1.1):<class 'float'>
클래스는 파이썬의 근간이 되는 개념

Cookie():
    def setdata(self, first, second):	//파이썬은 꼭 self 써야 함♣
        self.fitst=first
        self.second=second
a=Cookie()
a.setdata(4, 2)			//a→self, 4→first, 2→second

생성자 __init__()
인터프리터와 약속된 키워드. 생성자 이름은 __init__으로 정해져있음
객체가 생성되는 시점에 자동으로 호출
사실 상속받은 자식클래스에게 필요한 생성자가 부모클래스 생성자와 같다면 오버라이딩 필요 없지만
초기값 설정 이외에도 쓰이므로 습관적으로 써주자!

클래스 상속
: class 클래스명A(상속할 기존의 클래스명B)
어떤 라이브러리는 이미 컴파일이 끝난 binary, 즉 이진수 형태로 제공되어서 알아볼 수도, 수정할 수도 없게 제공된다
패키지를 만들어서 돈을 버는 회사는 당연히 그대로 보여주지 않는다^^ 이 때 사용됨

메소드 오버라이딩[덮어쓰기]
: A, B에 같은 이름의 메소드가 있다면 B는 무시하고 새로 업데이트된 A의 메소드로 사용
ex_ 나눗셈에서 0으로 나눌 때 원래는 오류뜨는데 새롭게 오류 처리된 메소드 정의하고 싶을 때

객체 변수(self.가 붙음)
생성, 사용 언제나 self. 붙여 써야 함. 각각의 객체에 종속되어 있어서 개별적		//id() 서로 다름

클래스 변수(self.가 붙지 않음)
해당 클래스를 공유하는 모든 객체들이 같이 쓰고 있어서 하나를 바꾸면 나머지도 바뀜	//id() 찍어보면 주소값도 똑같음. 완전히 same


'''