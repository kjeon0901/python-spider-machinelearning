'''
★
튜플 + → 연결		//대신 둘의 타입 달라도 됨
튜플 * → 곱한 만큼 반복
리스트 a=[1,2,3]에서 수정(a[1]=3→a=[1,3,3]), 삭제, 추가 모두 가능
튜플   a=(1,2,3)에서는 수정, 삭제 불가능, 추가만 가능
	//문자열과 동일
튜플 값 대입 식으로 수정 불가능
튜플 슬라이싱 가능
len(튜플) → 인풋값으로 들어온 튜플의 요소(element)의 개수 리턴
★


문자열, 리스트, 튜플은 모두 순차적으로(sequential=인덱스부여되는 자료형이네~) 인덱스를 부여하여 인덱스로 요소에 접근 가능
딕셔너리 != 순차적. key값을 통해서 원하는 것만 바로 찾는다. 인덱스를 key값이 대신.

딕셔너리 주의사항	→ 1. 딕셔너리의 key값은 단일요소여야 함. 
			문자열, 튜플, key값 고정된 딕셔너리 (o)	리스트, key값 변하는 딕셔너리 (x)
		→ 2. key값은 모두 달라야 함. 만약 같으면 마지막만 제외하고 나머지 모두 무시


★
딕셔너리 a={1:'a'}에서
추가 : a[2]='b' → a={1:'a', 2:'b'}
삭제 : del a[1] → a={2:'b'}
딕셔너리.keys() → 딕셔너리의 모든 key값을 담은 (리스트와 호환 가능하도록 정의된) dict_keys 클래스 객체를 리턴 → 리스트로 형변환하거나 for문으로 요소 하나씩 빼냄
			//보통 모든 건 형변환과 for문을 통해 내가 쉽게 사용할 수 있게 만들어져있음
딕셔너리.values() → 딕셔너리의 모든 value값을 담은 (리스트와 호환 가능하도록 정의된) dict_values 클래스 객체를 리턴 → 리스트로 형변환하거나 for문으로 요소 하나씩 빼냄
딕셔너리.items() → 딕셔너리 모든 쌍을 튜플로 묶은 값을 담은 (리스트와 호환 가능하도록 정의된) dict_items 클래스 객체를 리턴 → 리스트로 형변환하거나 for문으로 요소 하나씩 빼냄
딕셔너리.clear() → 딕셔너리 쌍 모두 삭제
딕셔너리.get(key값a) → a에 해당하는 value값 리턴
딕셔너리.pop(key값a) → a에 해당하는 value값 리턴하고 삭제	//딕셔너리는 sequential하지 않으므로 스택 개념이 x
key값a in 딕셔너리 → a가 딕셔너리 안에 있는지 T/F
	A='spring'	'sp' in A → True 리턴
	A={'name':'pey'}	'name' in A → True 리턴
sum(튜플) : 모든 요소의 합 리턴
★


집합 자료형 set
1. 중복x   unique한값만 의미있음
2. 순서x

s1=set([1,2,3,4,5,6]), s2=set([4,5,6,7,8,9])일 때
s1 & s2 : 교집합 → {4,5,6}
s1 | s2 : 합집합 → {1,2,3,4,5,6,7,8,9}
s1 - s2 : 차집합 → {1,2,3}

//가장많이쓰는 방법 : 하나의 row 또는 하나의 column을 리스트로 가져옴 → 집합자료형으로 캐스팅해서 하나씩 걸러냄 → 다시 리스트로 캐스팅
A=[1,4,2,3,1,2]
SA = set(A) 	//{1,4,2,3}
NEWA = list(SA) 	//[1,4,2,3]

자료형의 참과 거짓♣
문자열	"python"	       T     |     리스트	[1,2,3]	  T
	""	       F     |		[]	  F
숫자형	0이아닌숫자    T     |     튜플	(1,2,3)	  T
	0	       F     |		()	  F
None		       F     |     딕셔너리	{1:'dic'}	  T
		             | 		{}	  F

a=[1,2,3]
b=a		//a is b==True, id(a)==id(b). 완전히 동일한 주소값을 참조
b=a[:], b=copy(a)	//element만 동일할 뿐 다른 주소. element만 복사됨

'''