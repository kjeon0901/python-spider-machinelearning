#하나의 변수에 여러 줄의 문자열을 넣고 싶을 때 전체를 A='''~''', B="""~""" 처럼 묶어준다
#print() 함수에 마지막에 디폴트값으로 자동으로 개행문자라는 파라미터가 들어간다. print()로 개행 하기 싫다면 end=""로 마지막 파라미터 다시 설정해줌

'''
★
문자열 + → 연결		//a="a""b", b="a"+"b" 둘 다 "ab"로 연결됨
문자열 * → 곱한 만큼 반복
문자열 요소는 바꿀 수 X !!! (tuple이라는 데이터타입도 요소 추가는 가능하지만 삭제는 불가능)
요소 하나를 바꾸려면 문자열 슬라이싱[:]을 통해 새로운 문자열 만들어야 함
문자열 값 대입 식으로 수정 불가능
문자열 슬라이싱 가능
len(문자열) → 인풋값으로 들어온 문자열의 요소(element)의 개수
문자열.count('문자열a') → 문자열 중 문자열a의 개수 리턴
문자열.find('문자열a') → 문자열 중 문자열a가 처음 나온 인덱스 리턴	// 없으면 -1 리턴 (코드 안 멈추고 계속 진행)
문자열.index('문자열a') → 문자열 중 문자열a가 처음 나온 인덱스 리턴	// 없으면 error (코드 멈춤 => 예외처리필요)
'새문자열'.join(문자열or리스트or튜플) → 문자열or리스트or튜플의 각 요소 사이사이에 새문자열 삽입
	A='abcd'
	C=', '.join(A)	____  A='abcd', C='a, b, c, d'
	A=['a', 'b', 'c', 'd']	   //리스트 요소가 모두 문자열일 때만 가능!!
	C=', '.join(A)	____  A=['a', 'b', 'c', 'd'], C='a, b, c, d'     //string내장함수니까 결과값 C도 string
문자열.upper() / 문자열.lower() → 문자열을 대문자로 / 소문자로
문자열.lstrip() / 문자열.rstrip() / 문자열.strip() → 왼쪽 / 오른쪽 / 양쪽 공백 지우기
문자열.replace('a', 'b') → 문자열 안의 a를 b로 바꾸기
문자열.split('문자열a') → 문자열을 문자열a를 기준으로 나눔. 문자열a 안 넣어주면 공백 기준
★


%d, %c, %s, %f, %o(8진수), %x(16진수), %%(%) 등 형식지정자도 \n처럼 문자 그대로가 아니라 파이썬 인터프리터와 약속된 키워드의 역할 함
%s는 예외적으로 어떤 자료형 값을 넣든 알아서 해줌

___format 1. %사용___
>>> print("I eat %d apples so I was sick for %s days"%(3, "five"))
>>> A=[1, 2, 3, 4, 5]
      for idx, a in enumerate(A):
      print("I eat %d apples. "%A[idx])
-------------------------------------------------------
>>> I eat 3 apples so I was sick for five days
>>> I eat 1 apples. 
      I eat 2 apples. 
      I eat 3 apples. 
      I eat 4 apples. 
      I eat 5 apples. 

___format 2. format함수 사용___
>>> number=10
      day="three"
      print("I ate {0} apples so I was sick for {1} days. ".format(number, day))
>>> print("I ate {number} apples so I was sick for {day} days. ".format(number=10, day="three"))
-------------------------------------------------------
>>> I ate 10 apples so I was sick for three days. 
>>> I ate 10 apples so I was sick for three days. 

{0:<10}, {1:<10}, ... 10칸 확보 후 왼쪽 정렬
{0:>10}, {1:>10}, ... 10칸 확보 후 오른쪽 정렬
{0:^10}, {1:^10}, ... 10칸 확보 후 가운데 정렬
{0:=<10}, {1:=>10}, {2:=^10}... 10칸 확보 후 각각 정렬, 공백 =로 채우기
{0:!<10}, {1:!>10}, {2:!^10}... 10칸 확보 후 각각 정렬, 공백 !로 채우기

___format 3. f문자열 포매팅 사용 : 쉬움!___
>>> name='홍길동'
      age=30
      print( f"나의 이름은 {name}입니다. 나이는 {age}입니다. ")
>>> d = {'name'='홍길동', 'age':30}	#딕셔너리 (key,value) 이렇게 사용할수있음
      print( f"나의 이름은 {d["name"]}입니다. 나이는 {d["age"]}입니다. ")
----------------------------------------------------------------
>>> 나의 이름은 홍길동입니다. 나이는 30입니다.
>>> 나의 이름은 홍길동입니다. 나이는 30입니다.


★
리스트 + → 연결		//대신 둘 다 타입 같아야 함. 타입 캐스팅 필요
			3+"hi"	   (x)에러
			str(3)+"hi"   (o)
리스트 * → 곱한 만큼 반복
len(리스트) → 인풋값으로 들어온 리스트의 요소(element)의 개수 리턴
	↓↓↓얘네 대부분은 원본 데이터 자체를 건드림↓↓↓
리스트 값 대입 식으로 수정 가능
리스트 슬라이싱 가능
del(리스트[인덱스]) → 해당 인덱스 요소만 삭제
리스트.append(요소) → 맨 뒤에 요소 추가
	a.append()를 인터프리터가 읽었을 때 "a의 데이터 타입에서 지원하는 내장 함수 중에서 append()를 실행하겠다"라고 이해하는데
	앞에 a=[]가 정의되지 않는다면 애초에 a를 모르기 때문에 에러
리스트.sort() → 오름차순 정렬
리스트.reverse() → 현재 리스트를 역순으로 나열
리스트.index(인덱스) → 리스트의 해당 인덱스의 요소 리턴
리스트.count(x) → 리스트 중 x의 개수 리턴
리스트.insert(a, b) → 리스트의 a번째 위치에 b 삽입
리스트.remove(x) → 리스트에서 처음 나오는 x 삭제
리스트.pop() → 스택(후입선출) 개념. 맨 마지막 요소 리턴하고 그 요소는 리스트에서 삭제
리스트.pop(x) → x번째 요소 리턴하고 그 요소는 리스트에서 삭제
리스트.extend(리스트a) → 리스트+=리스트a 와 같음
sum(리스트) : 모든 요소의 합 리턴
★

'''